# -*- coding: utf-8 -*-
"""Agent addition

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NklzPAQtaLTa2E9eUjORVC1hNu2P88az
"""

"""#LOGS

1. Adding 2 additional agents that will create the jest.config file and the package.json
2. Adding gemini 2.5 pro exp
3. Use the manager LLM approach
"""

#API KEYS
import os
os.environ['EXA_API_KEY']
os.environ['OPENAI_API_KEY']

from crewai_tools import DirectoryReadTool
from crewai_tools import FileReadTool
from crewai_tools import CodeDocsSearchTool
from exa_py import Exa
from crewai.tools import tool

#TOOLS SET 1
directory_read_tool=DirectoryReadTool('gcc-national-registry-dashboard-Dev_Branch/server/src/controller')
file_read_tool=FileReadTool()
docs_search_tool=CodeDocsSearchTool('https://archive.jestjs.io/docs/en/22.x/getting-started.html')

#TOOLS SET 2
#Exa Search Tool
exa_api_key = os.getenv("EXA_API_KEY")

@tool("Exa search and get contents")
def search_and_get_contents_tool(question: str) -> str:
    """Tool using Exa's Python SDK to run semantic search and return result highlights."""

    exa = Exa(exa_api_key)

    response = exa.search_and_contents(
        question,
        type="neural",
        use_autoprompt=True,
        num_results=3,
        highlights=True
    )

    parsedResult = ''.join([
    f'<Title id="{idx}">{eachResult.title}</Title>'
    f'<URL id="{idx}">{eachResult.url}</URL>'
    f'<Highlight id="{idx}">{"".join(eachResult.highlights)}</Highlight>'
    for idx, eachResult in enumerate(response.results)
])

    return parsedResult

exa_tool=search_and_get_contents_tool

#LLMS
#Testing all LLM combinations
from crewai import LLM
llm_gemma_1=LLM(model="groq/gemma2-9b-it",api_key=,temperature=0) #chaitany_api_key
llm_gemma_2=LLM(model="groq/gemma2-9b-it",api_key=, temperature=0) #hardik_api_key
llm_openai_4o=LLM(model="openai/gpt-4o-mini",temperature=0)
llm_openai_o3=LLM(model="openai/o1-mini-2024-09-12", temperature=0)

"""Gemini 2.5 pro exp"""

llm_gemini=LLM(model='gemini/gemini-2.5-pro-exp-03-25',api_key=)
#add gemini 2 

from crewai import Agent, Task, Crew, Process

#Agent 1
#directory_listing_agent= This agent will retrieve the path of all the files in the directories.

directory_listing_agent=Agent(
    role="Directory Listing Agent",
    goal="Identify and return all file paths within the specified directory, including subdirectories.",
    backstory=(
            "This agent scans the entire directory and retrieves a structured list of file paths, "
            "which will be used for further content extraction and analysis."
        ),
    tools=[directory_read_tool],
    llm=llm_gemma_1,
    memory=True,
    verbose=True
    )

directory_listing_task=Task(
    description="Scan the specified directory and list all file paths, including those in subdirectories.",
    expected_output="A structured list of absolute file paths, saved in 'file_paths.md' with one file path per line.",
    agent= directory_listing_agent,
    output_file="file_paths_2.md"
)

#Agent 2
#file_extraction_agent= This agent will extract all the code

file_extraction_agent=Agent(
    role="Code File Consolidator",
    goal="Extract complete source code from multiple files and combine them into a single consolidated output while preserving file boundaries and organizational structure.",
    backstory="A specialized assistant that efficiently processes multiple source code files, extracts their full content without modification, and arranges them in a single organized document for comprehensive analysis.",
    tools=[file_read_tool],
    llm=llm_openai_4o,
    function_calling_llm=llm_gemma_2,
    memory=True,
    verbose=True,
)

file_extraction_task=Task(
    description="Extract all JavaScript code from the file paths provided by the directory_listing_task and save it as a single consolidated JavaScript file.",
    expected_output="""
    A JavaScript file (`extracted_code.js`) that contains all extracted JavaScript code from the file paths listed in 'file_paths.md', with the following requirements:

    1. IMPORTANT: Not a single line of code should be missed. Ensure 100% extraction accuracy from all listed files.
    2. Read and process each JavaScript file path provided in the output of directory_listing_task
    3. Each extracted file must begin with a clear file header showing the original filename
    4. All code, comments, and whitespace must be preserved exactly as found in the original files
    5. Files must be separated by clear visual delimiters for easy navigation
    6. The entire content of each file must be included with no truncation
    7. No explanations, summaries, or analysis of the code should be included
    8. The code must not be modified, optimized, or reformatted in any way
    9. If a file cannot be read, a comment documenting the specific error must be included
    10. Return only the consolidated file content - no additional commentary
    11. The entire content of each file should be accurately extracted
    """,
    agent=file_extraction_agent,
    context=[directory_listing_task],
    output_file="extracted_code.js"
)

#Agent 3- This agent will divide the code into units

code_segmentation_agent = Agent(
    role="JavaScript Code Unit Segmentation Agent",
    goal="Break down the extracted JavaScript code into individual units (functions, classes, modules, and components) for structured analysis.",
    backstory="This agent specializes in parsing JavaScript code structure to identify discrete functional units such as functions, classes, ES6 modules, React components, and other JavaScript-specific patterns, enabling effective dependency mapping and test generation.",
    llm=llm_openai_4o,
    function_calling_llm=llm_gemma_2,
    memory=True,
    verbose=True
)

code_segmentation_task = Task(
    description="Segment the extracted JavaScript code into logical units such as functions, classes, components, and modules. Each segment should be properly formatted and structured for easy analysis. Ensure EVERY code unit is identified and documented with no omissions.",
    expected_output="""
    A structured JavaScript file (`segments.js`) that contains each JavaScript code unit as an independent, clearly separated segment, with the following requirements:

    1. IMPORTANT: Every segment must include actual code from the original file. Do not generate placeholders, metadata-only entries, or empty sections. The code must be directly extracted, and no segment should be documented without its real source code block.

    2. Identify and separate ALL JavaScript-specific code units, including but not limited to:
      - ES6 classes and their methods
      - Function declarations and function expressions
      - Arrow functions that define components or utilities
      - ES6 modules (import/export statements)
      - React components (functional and class-based)
      - Object literals that define structured interfaces
      - Prototype-based inheritance patterns
      - IIFE (Immediately Invoked Function Expressions)
      - Event handlers and callbacks
      - Async functions and Promises
      - Anonymous functions and nested functions
      - Higher-order functions

    3. For each code unit, include:
      - Original file name
      - Line numbers (start-end) from the original file
      - Complete implementation with preserved formatting
      - Type of unit (function, class, component, etc.)
      - Dependencies and imports used by the unit

    4. Preserve JavaScript-specific patterns like closures and lexical scoping

    5. Track both CommonJS and ES6 module syntax appropriately

    6. Include module exports to document public interfaces

    7. Properly document framework-specific components (React, Vue, Angular, etc.)

    8. Organize segments hierarchically when appropriate (e.g., methods under their classes)

    9. Ensure COMPLETE coverage - every single line of code must be accounted for in at least one segment

    10. Do not omit any code segment

    11. For overlapping segments (e.g., a function within a class), include the code in both relevant sections with appropriate cross-references
    """,
    agent=code_segmentation_agent,
    context=[file_extraction_task],
    output_file="segments.js"
)

#Agent 4- This agent will generate the jest test cases

test_case_generator=Agent(
        role="Automated JavaScript Test Case Generator",
        goal="Analyze the segmented JavaScript code and generate comprehensive Jest test cases for each function, class, component, and module to ensure correctness, edge-case handling, and robustness.",
        backstory="An AI-powered JavaScript testing expert designed to deeply understand modern JS code structure, dependencies, and functionality. It generates precise and efficient Jest test cases covering various scenarios, including positive, negative, and edge cases, with special focus on asynchronous patterns and React components.",
        llm=llm_gemini,
        tools=[exa_tool, docs_search_tool],
        function_calling_llm=llm_gemma_2,
        memory=True,
        verbose=True,
)

test_case_generation_task = Task(
    description="Generate comprehensive Jest test cases for all JavaScript functions, classes, components, and modules based on the segmented code structure.",
    expected_output="""
==================== ‚ö†Ô∏è IMPORTANT INSTRUCTIONS ‚ö†Ô∏è ====================

DO NOT SKIP ANY CODE UNITS.

üî¥ You MUST write unit and integration tests for **EVERY** function, class, component, and module.
üî¥ DO NOT suggest that other units will be "similar" and can be skipped.
üî¥ This system is intended for **automation**‚Äîmanual effort must be **eliminated**.
üî¥ Provide **explicit and complete Jest test cases** for each identified unit.
üî¥ Your output will be directly used in a CI/CD pipeline; incomplete outputs are unacceptable.

======================================================================

‚úÖ OUTPUT REQUIREMENT:
A complete and organized set of Jest test files that includes:

1. **Test Coverage Goal**:
   - At least **90% code coverage** for **statements**, **branches**, **functions**, and **lines** using `jest --coverage`.
   - Include:
     - Valid input scenarios (happy path)
     - Edge cases (`null`, `undefined`, empty arrays/objects, min/max values)
     - Error handling and exception cases
     - Asynchronous testing (Promises, async/await)

2. **Dependencies**:
   - Mock unavailable or external dependencies using:
     - `jest.mock()` for modules
     - `jest.fn()` for functions with custom return values
     - Mock API calls and services

3. **React Component Testing (if applicable)**:
   - Use **React Testing Library** or **Enzyme**
   - Test:
     - Component rendering
     - Interaction/behavior
     - Context providers / Redux stores (mocked where required)

4. **Test Structure**:
   - Group tests using `describe` blocks
   - Setup/teardown with `beforeEach`, `afterEach` as needed
   - Maintain clarity between unit tests and integration tests

5. **File Format and Content**:
   - Reference original file/function/class names
   - Include all necessary imports
   - Follow Jest file naming conventions (`*.test.js` or `*.spec.js`)
   - Use Jest matchers (`toEqual`, `toBe`, `toThrow`, `toHaveBeenCalledWith`, etc.)

6. **Utilities**:
   - Include reusable fixtures or factory functions for test data

7. **Tools Usage**:
   - Actively use the provided tools:
     - `exa_tool` for researching JS testing best practices
     - `docs_search_tool` for Jest syntax, matchers, and strategies
   - Use tools to find strategies for complex patterns or framework-specific behaviors

8. **Path to Follow (Module Hierarchy)**:
   üîΩ Begin writing test cases in the following strict hierarchical order:

   /db/models          ‚Üí Write unit tests for all DB models  
   /services           ‚Üí Write tests for service functions (unit + integration)  
   /controller         ‚Üí Write controller tests (mock services and DB)  
   /middleware         ‚Üí Write middleware logic tests  
   /routes             ‚Üí Write route-level integration tests  

   - For each folder/unit, generate a corresponding `*.test.js` file.
   - Maintain folder structure and clearly label each test file.
   - Use mocks for lower-level dependencies when testing higher-level modules.

9. **Sequelize Mocking (Mandatory)**:
   - All Sequelize-based DB models must be mocked to avoid real DB interaction.
   - Use one of the following strategies:

     **a. Using `sequelize-mock`** (Recommended for model-level unit testing):
     ```js
     const SequelizeMock = require('sequelize-mock');
     const DBMock = new SequelizeMock();

     const UserMock = DBMock.define('User', {
       id: 1,
       name: 'Test User'
     });

     test('should fetch user', async () => {
       const user = await UserMock.findOne({ where: { id: 1 } });
       expect(user.get('name')).toBe('Test User');
     });
     ```

     **b. Using `jest.mock()` for existing model files**:
     ```js
     jest.mock('../../db/models/User', () => {
       return {
         findOne: jest.fn().mockResolvedValue({ id: 1, name: 'Mocked User' }),
         create: jest.fn().mockResolvedValue({ id: 2, name: 'Created User' })
       };
     });
     ```

   - Mock all standard Sequelize methods: `findOne`, `findAll`, `create`, `update`, `destroy`, etc.
   - Ensure these mocks are used consistently in service and controller layer tests.

üéØ Final Output:
A complete Jest test suite, with a dedicated test file for each code unit/module, organized by hierarchy, containing full coverage tests (unit + integration) ready for CI/CD pipelines.
""",
    agent=test_case_generator,
    context=[code_segmentation_task],
    output_file="test_cases.test.js"
)




# --- Agent for Jest Configuration ---
jest_config_agent = Agent(
    role="Jest Configuration Architect",
    goal="Design a fast, ESModule-compatible Jest configuration for backend Node.js projects using modern JavaScript and folder structures like `src/`, `controller/`, and `__tests__/`.",
    backstory=(
        "You are an expert in backend testing and configuration design. "
        "You specialize in setting up Jest for modern Node.js projects that use ES Modules (via `type: module`) and optimized transformers like `@swc/jest`. "
        "You're aware of how test environments, file structure, and transform settings interact and how to tune them for best performance."
    ),
    llm=llm_gemini,
    memory=True,
    verbose=True
)

# --- Task for Jest Configuration ---
jest_config_task = Task(
    description=(
        "Generate a fully compatible and optimized `jest.config.js` for a modern Node.js backend project using JavaScript ES Modules. "
        "The project structure includes `src/`, optional subfolders like `controller/`, `services/`, and colocated `__tests__` directories. "
        "The configuration must match the test structure and transform logic required to run the Jest test files produced in the test case generation step."
    ),
    expected_output=(
        "A valid and complete `jest.config.js` file that includes:\n"
        "- `testEnvironment: 'node'`\n"
        "- `transform` using `@swc/jest` with:\n"
        "   - Parser: `ecmascript`, no JSX\n"
        "   - Target: `es2020`\n"
        "   - Module output set to ESM (`type: 'es6'`)\n"
        "   - Source maps enabled with `sourceMaps: 'inline'`\n"
        "- `testMatch` targeting `.test.js` files in `__tests__/` subfolders based on the segmented test structure\n"
        "- `moduleFileExtensions` including: ['js', 'mjs', 'cjs', 'json', 'node']\n"
        "- `moduleDirectories` set to ['node_modules', '<rootDir>/src'] based on source structure\n"
        "- `roots` pointing to the source root folder(s) (e.g., `<rootDir>/src`)\n"
        "- `collectCoverage: true` to collect test coverage on application code\n"
        "- `coverageDirectory` set to 'coverage'\n"
        "- `clearMocks: true` to reset all mocks automatically before each test\n"
        "- `maxWorkers: 1` to serialize test execution (safe for shared state)\n"
        "- Must exclude deprecated fields such as `extensionsToTreatAsEsm`\n"
        "- Must assume that `package.json` includes `type: module`\n"
        "- Ensure compatibility with test files generated using dynamic import syntax and `jest.unstable_mockModule`\n"
        "- The config must be able to run all tests generated from the segmented code structure and `jest_test_cases`"
    ),
    agent=jest_config_agent,
    context=[
        directory_listing_task,
        file_extraction_task,
        code_segmentation_task,
        test_case_generation_task
    ],
    output_file="jest.config.js"
)


# --- Agent for Package.json Generation ---
package_json_agent = Agent(
    role="Node.js Package Setup Expert",
    goal="Create a minimal and optimized package.json for a backend project using Jest and ES Modules, ensuring devDependencies and scripts match the test setup.",
    backstory=(
        "You are an expert in Node.js toolchains. You help developers configure their projects using best practices. "
        "You specialize in writing minimal `package.json` files that support Jest testing, mock libraries like `node-mocks-http`, and ESModule configurations."
    ),
    llm=llm_gemini,
    memory=True,
    verbose=True,
)

# --- Task for Package.json Generation ---
package_json_task = Task(
    description=(
        "Generate a complete `package.json` file for a backend Node.js project written using modern JavaScript and ES Modules. "
        "The project uses Jest for testing, `@swc/jest` for transformation, and includes a file structure with folders like `src/`, `controller/`, `services/`, and `__tests__/`. "
        "The generated file should fully support test execution, development, documentation, and mock infrastructure as identified from the extracted source code and Jest configuration."
    ),
    expected_output=(
        "A valid and complete `package.json` file that includes:\n"
        "- Basic metadata:\n"
        "   - `name`: the project name (fallback to generic if unknown)\n"
        "   - `version`: '1.0.0'\n"
        "   - `type`: 'module' (to support ES Modules syntax)\n"
        "   - `main`: set to the main application entry point (e.g., `src/server.js` or auto-detect from extracted code)\n"
        "\n"
        "- Scripts:\n"
        "   - `test`: run Jest with coverage collection (`jest --coverage`)\n"
        "   - `dev`: run the main app file with `nodemon`\n"
        "   - `docs`: optionally generate documentation using JSDoc (`jsdoc -c jsdoc.json`)\n"
        "\n"
        "- `devDependencies` must include:\n"
        "   - `jest` (version inferred from `jest.config.js` or latest v29+)\n"
        "   - `@swc/jest` for transforming JS/ESM\n"
        "   - `node-mocks-http` for request/response testing\n"
        "   - `sequelize-mock` if Sequelize usage is found in `extracted_code`\n"
        "   - `nodemon` (if `dev` script is present)\n"
        "   - `jsdoc` (if `docs` script is present)\n"
        "\n"
        "- The file should:\n"
        "   - Match `jest.config.js` assumptions (e.g., type: module, test runner)\n"
        "   - Reflect only backend dependencies ‚Äî no React, TypeScript, Webpack, Babel, or frontend frameworks\n"
        "   - Avoid redundant or unnecessary packages\n"
        "   - Output valid JSON (no comments, no trailing commas)\n"
        "\n"
        "- The structure of the project (as inferred from context) includes `src/`, `controller/`, `services/`, and `__tests__/`, and tests rely on mocking and dynamic import syntax (`await import(...)`, `jest.unstable_mockModule()`)\n"
        "- Ensure compatibility with ESM runtime and Node >= 16\n"
    ),
    agent=package_json_agent,
    context=[
        file_extraction_task,
        code_segmentation_task,
        jest_config_task
    ],
    output_file="package.json"
)





#The Corrections Crew
test_case_correction_agent = Agent(
    role="Automated Test Case Reviewer and Corrector",
    goal="Analyze, validate, and correct Jest test cases for structural correctness, runtime compatibility, ESM support, and mock consistency to ensure all test files are CI-ready and error-free.",
    backstory=(
        "You are a highly skilled test reviewer with deep expertise in Jest, ES Modules, asynchronous JavaScript, and mocking frameworks. "
        "Your job is to inspect automatically generated test cases, identify and fix any runtime, import, mocking, or syntax issues. "
        "You ensure each test is fully compatible with ESM (import/export), mocks Sequelize and services correctly, and follows Jest best practices. "
        "Your corrections are critical for maintaining CI/CD reliability and 100% automation in the testing pipeline."
    ),
    llm=llm_gemini,
    memory=True,
    verbose=True
)

test_case_correction_task = Task(
    description=(
        "Review and correct all Jest test cases generated from the segmented JavaScript code to ensure they are syntactically valid, fully functional, and compatible with the ES Module-based Node.js backend architecture. "
        "The test cases should follow best practices, support Sequelize mocking, and be compatible with dynamic `await import()` syntax and `jest.unstable_mockModule`. "
        "Ensure each test runs successfully in CI/CD pipelines without any manual changes."
    ),
    expected_output=(
        "A fully corrected and validated Jest test suite that meets the following requirements:\n\n"
        "1. **Syntax & Runtime Compatibility**:\n"
        "   - All test files use proper ESM syntax (`import`, `export`) and no CommonJS (`require()` or `module.exports`)\n"
        "   - Dynamic imports (`await import(...)`) and `jest.unstable_mockModule()` are correctly used where necessary\n"
        "   - Async tests use `async/await` correctly and all Promises are handled\n\n"
        "2. **Mocking Validation**:\n"
        "   - External dependencies are mocked using `jest.mock()` or `jest.unstable_mockModule()`\n"
        "   - Sequelize models must be mocked using `sequelize-mock` or manual mocks via `jest.mock()`\n"
        "   - Service and DB layer mocks return meaningful and testable values (e.g., `mockResolvedValue()`)\n"
        "   - `jest.fn()` is used consistently for custom mock functions\n\n"
        "3. **Structural Quality**:\n"
        "   - Each test is enclosed in descriptive `describe()` and `test()` or `it()` blocks\n"
        "   - Tests must follow proper isolation using `beforeEach`, `afterEach`, or mock resets\n"
        "   - Each test case should target a specific code unit (function, class, module)\n\n"
        "4. **Coverage Completeness**:\n"
        "   - Missing test cases for detected segments should be added\n"
        "   - Must account for edge cases, invalid inputs, error handling, and async failure scenarios\n\n"
        "5. **Formatting & Imports**:\n"
        "   - All required imports must be valid and correctly referenced\n"
        "   - File paths for module mocks should match segmented structure (e.g., `../../db/models/...`)\n"
        "   - Output files follow Jest naming conventions (`*.test.js`) and reside in `__tests__` folders\n\n"
        "6. **Output Format**:\n"
        "   - Return a single valid JavaScript file (`corrected_test_cases.test.js`) containing all corrected test cases\n"
        "   - Do not include explanations or surrounding commentary ‚Äî only executable, corrected code\n\n"
        "Tests must run successfully when executed using `jest --coverage` in the configured CI pipeline."
    ),
    agent=test_case_correction_agent,
    context=[
        test_case_generation_task
    ],
    tools=[exa_tool, docs_search_tool],
    function_calling_llm=llm_gemma_2,
    output_file="corrected_test_cases.test.js"
)




jest_config_correction_agent = Agent(
    role="Jest Configuration Validator and Corrector",
    goal="Analyze and correct the Jest configuration file to ensure it is fully compatible with an ES Module-based Node.js backend and the test cases it is intended to run.",
    backstory=(
        "You are a Jest configuration specialist with deep expertise in modern JavaScript tooling, ESModules, and transformer performance tuning. "
        "You are responsible for ensuring that the jest.config.js file aligns with the test architecture, handles dynamic imports correctly, avoids deprecated options, "
        "and works with SWC, mocking strategies, and file system conventions used in modern backends. "
        "You proactively identify misconfigurations and provide corrected versions ready for CI/CD integration."
    ),
    llm=llm_gemini,
    memory=True,
    verbose=True
)

jest_config_correction_task = Task(
    description="Review the generated `jest.config.js` file and correct any issues related to test file matching, ESM compatibility, SWC transform settings, coverage settings, or deprecated fields.",
    expected_output="""
A corrected and validated Jest configuration file (`jest.config.reviewed.js`) that:

1. Ensures `testEnvironment: 'node'` is present and correct.
2. Validates `transform` block uses `@swc/jest` with proper `ecmascript` parsing and ESM module output.
3. Verifies `testMatch` patterns align with the actual structure of test files.
4. Includes the right `moduleFileExtensions` for the backend project.
5. Uses `moduleDirectories` and `roots` that match actual project folders (`src/`, etc.).
6. Enables `collectCoverage: true` and sets `coverageDirectory` properly.
7. Confirms `clearMocks: true` and `maxWorkers` settings are safe and optimized.
8. Removes or avoids deprecated options such as `extensionsToTreatAsEsm`.
9. Matches assumptions from `test_case_generation_task` (e.g., dynamic `await import()`, `jest.unstable_mockModule`).
10. Returns a final, corrected config file named `jest.config.reviewed.js`.

Do not include summaries or explanation‚Äîonly corrected, executable config code.
""",
    agent=jest_config_correction_agent,
    context=[jest_config_task, test_case_generation_task, code_segmentation_task],
    output_file="jest.config.reviewed.js"
)




package_json_correction_agent = Agent(
    role="Package.json Configuration Reviewer and Fixer",
    goal="Analyze and correct the project's package.json file to ensure it accurately reflects the backend structure, test setup, and dev tooling required for modern ES Module-based Node.js projects using Jest.",
    backstory=(
        "You are a Node.js configuration and dependency expert responsible for validating and correcting package.json files. "
        "You ensure all scripts, metadata, and dependencies align with the codebase and test environment. "
        "You specialize in backend tooling, Jest integration, SWC transformers, mock dependencies, and ESM compatibility. "
        "Your job is to prevent runtime issues and misconfigurations that can break test execution, development workflows, or CI pipelines."
    ),
    llm=llm_gemini,
    memory=True,
    verbose=True
)

package_json_correction_task = Task(
    description="Review and correct the generated `package.json` file to ensure that all fields, dependencies, and scripts match the actual project structure, ESM requirements, and Jest setup.",
    expected_output="""
A corrected `package.json` file (`package.reviewed.json`) that includes:

1. ‚úÖ Accurate metadata:
   - `"name"` and `"version"` are valid
   - `"type": "module"` is included for ESM projects
   - `"main"` points to a real file in the project (e.g., `src/server.js`)

2. ‚úÖ Complete and correct scripts:
   - `"test"` runs `jest --coverage`
   - `"dev"` runs the entry point using `nodemon`
   - `"docs"` runs `jsdoc` if documentation is expected

3. ‚úÖ Dev dependencies that match the tooling:
   - `jest` and `@swc/jest` for testing
   - `node-mocks-http` for HTTP mocking
   - `sequelize-mock` if Sequelize usage is detected
   - `nodemon` and `jsdoc` if referenced in scripts

4. ‚úÖ No unnecessary or frontend packages:
   - No React, Babel, TypeScript, Webpack, or frontend libraries unless used

5. ‚úÖ ESM and Jest compatibility:
   - Ensures all tools in the config support ESM and are used correctly
   - Aligns versions of tools with test and config file syntax

6. ‚úÖ Output:
   - A fully corrected `package.json` with no comments, no trailing commas, and valid JSON syntax

""",
    agent=package_json_correction_agent,
    context=[package_json_task, file_extraction_task, jest_config_task],
    output_file="package.reviewed.json"
)




final_summary_agent = Agent(
    role="Final Codebase Summary Auditor",
    goal="Analyze all corrected files (test cases, jest config, package.json) and generate a markdown summary of test, configuration, and deployment readiness.",
    backstory=(
        "You are a senior CI/CD validator responsible for final review before deployment or merging. "
        "You evaluate the structure, syntax, and tooling correctness of all critical files in the Node.js backend system "
        "including the Jest config, test cases, and package configuration. "
        "You generate a concise final report that confirms readiness or flags specific areas for human attention."
    ),
    llm=llm_gemini,
    memory=True,
    verbose=True
)

final_summary_task = Task(
    description=(
        "Review the final outputs: `corrected_test_cases.test.js`, `jest.config.reviewed.js`, and `package.reviewed.json`. "
        "Evaluate them for test compatibility, config correctness, and CI/CD readiness. "
        "Ensure all files are complete, runnable, and aligned with ESM standards. "
        "Summarize the results in a markdown report with a CI deployment readiness checklist."
    ),
    expected_output="""
A final summary report in Markdown (`final_summary.md`) that includes:

## ‚úÖ Final Test & Configuration Summary

### 1. ‚úÖ Jest Test Suite
- [ ] All test cases are syntactically valid and pass linting
- [ ] Sequelize models are mocked properly
- [ ] Dynamic import usage (`await import()`) is valid
- [ ] Test files follow `.test.js` conventions in `__tests__/`

### 2. ‚úÖ Jest Configuration
- [ ] ESM-compatible (`type: 'module'`)
- [ ] `@swc/jest` transform present with proper parser/module settings
- [ ] No deprecated fields (e.g., `extensionsToTreatAsEsm`)
- [ ] `testMatch` paths reflect segmented test structure

### 3. ‚úÖ Package.json
- [ ] Scripts (`test`, `dev`, `docs`) are complete
- [ ] Required `devDependencies` are present (e.g., `jest`, `@swc/jest`, mocks)
- [ ] No unused or frontend libraries included
- [ ] `main` file exists and is correctly linked

### 4. ‚úÖ CI/CD Readiness
- [ ] Jest runs with `--coverage`
- [ ] Coverage goal: ‚â• 90% branches, statements, functions, lines
- [ ] Files are named properly and safe for Git merge/deploy

### üì¶ Files Reviewed
- `corrected_test_cases.test.js`
- `jest.config.reviewed.js`
- `package.reviewed.json`

If any box cannot be checked, describe the issue in a bullet point list below:

### ‚ùå Issues Found
- <if any>

""",
    agent=final_summary_agent,
    context=[
        test_case_correction_task,
        jest_config_correction_task,
        package_json_correction_task
    ],
    output_file="final_summary.md"
)





#Testing the Agents
testing_crew = Crew(
    agents=[
        directory_listing_agent,
        file_extraction_agent,
        code_segmentation_agent,
        test_case_generator,
        jest_config_agent,
        package_json_agent,
        test_case_correction_agent,
        jest_config_correction_agent,      
        package_json_correction_agent,
        final_summary_agent     
    ],
    tasks=[
        directory_listing_task,
        file_extraction_task,
        code_segmentation_task,
        test_case_generation_task,
        jest_config_task,
        package_json_task,
        test_case_correction_task,
        jest_config_correction_task,       
        package_json_correction_task,
        final_summary_task       
    ],
    process=Process.sequential
)

testing_crew.kickoff()
